<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>When Pigs Fly</title>

  <!-- three.js r128 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- GLTFLoader (r128 호환) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      background: #87CEEB;
    }

    /* 배경 이미지 */
    .background-image {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: -1;
    }

    #container {
      width: 100vw;
      height: calc(100vh - 18vh);
      min-height: calc(100vh - 180px);
      cursor: move;
      touch-action: none;
    }

    @media (max-width: 768px) {
      #container {
        height: calc(100vh - 20vh);
        min-height: calc(100vh - 120px);
      }
    }

    /* 로딩 화면 */
    .loading-screen {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #87CEEB 0%, #B0D4E3 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      transition: opacity 0.5s;
    }

    .loading-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 5px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .loading-text {
      margin-top: 20px;
      color: white;
      font-size: 18px;
      font-weight: 600;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* 상단 바 */
    .top-bar {
      position: fixed;
      top: 0; left: 0; right: 0;
      width: 100%;
      height: 12px;
      z-index: 2000;
      background: repeating-linear-gradient(
        90deg,
        #574429 -2px,
        #574429 40px,
        #B8CFFF 39px,
        #B8CFFF 74px
      );
    }

    .top-bar img { display: none; }

    /* 로고 버튼 */
    .logo-buttons {
      position: absolute;
      top: 2vh;
      left: 2vw;
      display: flex;
      flex-direction: column;
      gap: 0.3vh;
      z-index: 500;
    }

    .logo-button {
      width: 8vw;
      height: 8vw;
      min-width: 60px;
      min-height: 60px;
      max-width: 120px;
      max-height: 120px;
      cursor: pointer;
      transition: transform 0.3s;
      background: transparent;
      overflow: visible;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .logo-button:hover { transform: scale(1.1); }

    .logo-button img {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* 텍스트 박스 (버튼2용) */
    .info-box {
      position: absolute;
      top: calc(2vh + 16.5vw + 0.5vh);
      left: 2vw;
      background: rgba(255, 255, 255, 0.95);
      padding: 1.5vw;
      max-width: 25vw;
      min-width: 200px;
      z-index: 500;
      opacity: 0;
      transform: translateY(-20px);
      pointer-events: none;
      transition: all 0.3s;
      border: 3px dashed #30210A;
    }

    .info-box.show {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .info-box h3 {
      margin-bottom: 10px;
      color: #333;
      font-size: clamp(14px, 1.2vw, 16px);
    }

    .info-box p {
      color: #666;
      font-size: clamp(12px, 1vw, 14px);
      line-height: 1.6;
    }

    /* 컨트롤 패널 */
    .control-panel {
      position: fixed;
      top: 4vh;
      right: 2vw;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      padding: 1.5vw;
      min-width: 180px;
      max-width: 250px;
      z-index: 500;
    }

    .control-item {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 15px;
    }

    .control-item:last-child { margin-bottom: 0; }

    .control-label {
      font-size: clamp(11px, 1vw, 13px);
      color: #333;
      min-width: 70px;
    }

    input[type="range"] {
      flex: 1;
      height: 6px;
      background: rgba(0, 0, 0, 0.15);
      outline: none;
      cursor: pointer;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #574429;
      cursor: pointer;
    }

    /* 포스터 갤러리 */
    .poster-gallery {
      position: fixed;
      bottom: 0;
      left: 0; right: 0;
      height: 18vh;
      min-height: 120px;
      max-height: 180px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 1vh 20px;
      gap: 0.8vw;
      overflow-x: auto;
      overflow-y: hidden;
      z-index: 1100;

      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
    }

    .poster-gallery::-webkit-scrollbar { height: 8px; }
    .poster-gallery::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.05); }
    .poster-gallery::-webkit-scrollbar-thumb { background: rgba(0, 0, 0, 0.2); }

    .poster-item {
      flex-shrink: 0;
      width: 5vw;
      min-width: 60px;
      max-width: 100px;
      aspect-ratio: 1 / 1.414;
      background: #f0f0f0;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      position: relative;
    }

    .poster-item:hover {
      transform: translateY(-10px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    }

    .poster-item.active { transform: translateY(-5px); }

    .poster-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .poster-placeholder {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #999;
      font-size: clamp(9px, 0.8vw, 11px);
      text-align: center;
      padding: 5px;
    }

    @media (max-width: 1200px) and (min-width: 769px) {
      .about-content {
        flex-direction: row;
        align-items: flex-start;
      }

      .about-image {
        width: 40vw;
        max-width: 350px;
      }

      .about-text {
        width: 100%;
        text-align: left;
      }
    }

    @media (max-width: 768px) {
      .control-panel { display: none; }

      .info-box {
        max-width: 80vw;
        min-width: 180px;
        top: calc(2vh + 16vw + 0.5vh);
      }

      .logo-buttons {
        top: 15px;
        left: 10px;
      }

      .logo-button {
        width: 60px;
        height: 60px;
        min-width: 60px;
        min-height: 60px;
      }

      .toggle-button {
        width: 65px;
        height: 65px;
        min-width: 65px;
        min-height: 65px;
        bottom: calc(20vh + 3vh);
        font-size: 11px;
      }

      .poster-gallery {
        height: 20vh;
        min-height: 100px;
        padding: 0.5vh 15px 2vh 15px;
        gap: 10px;
      }

      .poster-item {
        width: 70px;
        min-width: 70px;
      }

      .about-overlay { padding: 5vh 3vw 25vh 3vw; }

      .about-content {
        flex-direction: column;
        gap: 3vh;
        align-items: center;
        justify-content: flex-start;
      }

      .about-image {
        width: 70vw;
        max-width: 300px;
        margin: 0 auto;
      }

      .about-text {
        min-width: auto;
        width: 100%;
        text-align: left;
      }

      .about-text h2 { font-size: 18px; text-align: left; }
      .about-scroll p { font-size: 14px; text-align: left; }
      .about-contact { font-size: 14px; align-items: flex-start; }
    }

    @media (max-width: 480px) {
      .poster-gallery {
        gap: 8px;
        padding: 0.3vh 12px 2.5vh 12px;
        height: 16vh;
      }

      .poster-item {
        width: 60px;
        min-width: 60px;
      }

      .about-image {
        width: 80vw;
        margin: 0 auto;
      }

      .toggle-button {
        bottom: calc(20vh + 2.5vh);
        margin-bottom: -3vh;
      }

      /* (너가 원래 넣어둔 특이한 스타일 유지) */
      .logo-button img {
        width: 140%;
        height: 140%;
        margin-top: 114px;
        margin-left: 39px;
        display: block;
      }

      .top-bar {
        height: -57px;
        opacity: 0;
      }
    }

    /* About 오버레이 */
    .about-overlay {
      position: fixed;
      bottom: -100%;
      left: 0; right: 0;
      height: 100%;
      background: rgba(48, 33, 10, 0.95);
      z-index: 1000;
      transition: bottom 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 8vh 5vw 25vh 5vw;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .about-overlay.show { bottom: 0; }

    .about-content {
      display: flex;
      gap: 5vw;
      max-width: 1400px;
      width: 100%;
      align-items: flex-start;
    }

    .about-image {
      flex-shrink: 0;
      width: 25vw;
      min-width: 250px;
      max-width: 400px;
      aspect-ratio: 1 / 1.414;
      background: white;
      overflow: hidden;
    }

    .about-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .about-text {
      flex: 1;
      color: white;
      min-width: 300px;
    }

    .about-text h2 {
      font-size: clamp(20px, 2vw, 28px);
      margin-bottom: 3vh;
      border-bottom: 2px solid rgba(255, 255, 255, 0.3);
      padding-bottom: 2vh;
    }

    .about-scroll {
      max-height: 50vh;
      overflow-y: auto;
      padding-right: 15px;
      margin-bottom: 3vh;
    }

    .about-scroll::-webkit-scrollbar { width: 8px; }
    .about-scroll::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); }
    .about-scroll::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); }

    .about-scroll p {
      line-height: 1.8;
      margin-bottom: 15px;
      font-size: clamp(13px, 1.2vw, 16px);
    }

    .about-contact {
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: clamp(13px, 1.2vw, 16px);
    }

    .about-contact a {
      color: white;
      text-decoration: none;
      transition: opacity 0.3s;
    }

    .about-contact a:hover { opacity: 0.7; }

    /* About/Back 버튼 */
    .toggle-button {
      position: fixed;
      bottom: calc(20vh + 2vh);
      right: 3vw;
      width: 6vw;
      height: 6vw;
      min-width: 65px;
      min-height: 65px;
      max-width: 100px;
      max-height: 100px;
      border-radius: 50%;
      background: #574429;
      color: white;
      font-size: clamp(11px, 1vw, 14px);
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
      z-index: 1200;
    }

    .toggle-button.back {
      background: #B8CFFF;
      color: #333;
    }

    .toggle-button:hover { transform: scale(1.1); }
  </style>
</head>

<body>
  <!-- 배경 이미지 -->
  <img src="background.jpg" class="background-image" alt="Background">

  <!-- 로딩 화면 -->
  <div class="loading-screen" id="loadingScreen">
    <div class="loading-spinner"></div>
    <div class="loading-text">Loading 3D Model...</div>
  </div>

  <!-- 상단 바 -->
  <div class="top-bar"></div>

  <!-- 로고 버튼 -->
  <div class="logo-buttons">
    <div class="logo-button" id="button1">
      <img src="button1.svg" alt="Logo 1">
    </div>
    <div class="logo-button" id="button2">
      <img src="button2.svg" alt="Logo 2">
    </div>
  </div>

  <!-- 정보 박스 (버튼2용) -->
  <div class="info-box" id="infoBox">
    <h3>프로젝트 정보</h3>
    <p>When Pigs Fly는 디자이너들의 사고 구조에서 과감히 벗어나 불가능을 즐기고, 낯선 그 대로의 디무니함을 디자인으로 마음껏 만들 수 있는 자리가 되었으면 좋겠습니다.</p>
  </div>

  <!-- 3D 컨테이너 -->
  <div id="container"></div>

  <!-- 컨트롤 패널 -->
  <div class="control-panel">
    <div class="control-item">
      <span class="control-label">회전 속도</span>
      <input type="range" id="rotationSpeed" min="0" max="2" step="0.1" value="0.5">
    </div>
    <div class="control-item">
      <span class="control-label">확대/축소</span>
      <input type="range" id="scaleSlider" min="0.5" max="3" step="0.1" value="1">
    </div>
  </div>

  <!-- About/Back 버튼 -->
  <div class="toggle-button" id="toggleButton">ABOUT</div>

  <!-- About 오버레이 -->
  <div class="about-overlay" id="aboutOverlay">
    <div class="about-content">
      <div class="about-image" id="aboutImage">
        <img src="" alt="Selected Poster">
      </div>
      <div class="about-text">
        <h2>포스터 제목</h2>
        <div class="about-scroll">
          <p>포스터에 대한 설명이 여기에 표시됩니다.</p>
        </div>
        <div class="about-contact">
          <a href="https://instagram.com/surreisjlsej" target="_blank">@surreisjlsej</a>
          <a href="mailto:dmsj@gmal.com">dmsj@gmal.com</a>
        </div>
      </div>
    </div>
  </div>

  <!-- 포스터 갤러리 -->
  <div class="poster-gallery" id="posterGallery"></div>

  <script>
    // 포스터별 데이터
    // 포스터별 데이터 (문법 안전 버전)
const posterData = {
  1: {
    title: "<희망밤 물화>",
    text: "디자인은 언제나 규칙과 목적이 있어야 한다고 믿으시나요? 익숙한 틀과 평범한 결과물은 더 이상 우리에게 영감을 주지 못합니다. {When Pigs Fly}는 '디무니함' 그 자체를 시각적으로 수집하는 프로젝트입니다.",
    instagram: "@artist1",
    email: "artist1@gmail.com"
  },
  2: { title: "포스터 2", text: "포스터 2에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist2", email: "artist2@gmail.com" },
  3: { title: "포스터 3", text: "포스터 3에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist3", email: "artist3@gmail.com" },
  4: { title: "포스터 4", text: "포스터 4에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist4", email: "artist4@gmail.com" },
  5: { title: "포스터 5", text: "포스터 5에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist5", email: "artist5@gmail.com" },
  6: { title: "포스터 6", text: "포스터 6에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist6", email: "artist6@gmail.com" },
  7: { title: "포스터 7", text: "포스터 7에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist7", email: "artist7@gmail.com" },
  8: { title: "포스터 8", text: "포스터 8에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist8", email: "artist8@gmail.com" },
  9: { title: "포스터 9", text: "포스터 9에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist9", email: "artist9@gmail.com" },
  10:{ title: "포스터 10", text: "포스터 10에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist10", email: "artist10@gmail.com" },
  11:{ title: "포스터 11", text: "포스터 11에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist11", email: "artist11@gmail.com" },
  12:{ title: "포스터 12", text: "포스터 12에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist12", email: "artist12@gmail.com" },
  13:{ title: "포스터 13", text: "포스터 13에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist13", email: "artist13@gmail.com" },
  14:{ title: "포스터 14", text: "포스터 14에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist14", email: "artist14@gmail.com" },
  15:{ title: "포스터 15", text: "포스터 15에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist15", email: "artist15@gmail.com" },
  16:{ title: "포스터 16", text: "포스터 16에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist16", email: "artist16@gmail.com" },
  17:{ title: "포스터 17", text: "포스터 17에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist17", email: "artist17@gmail.com" },
  18:{ title: "포스터 18", text: "포스터 18에 대한 설명입니다. 여기에 작가의 작품 설명과 컨셉을 작성하세요.", instagram: "@artist18", email: "artist18@gmail.com" }
};


    // About 텍스트 업데이트 함수
    function updateAboutText(posterIndex) {
      const data = posterData[posterIndex];
      if (!data) return;

      document.querySelector('.about-text h2').textContent = data.title;
      document.querySelector('.about-scroll p').textContent = data.text;

      const ig = document.querySelector('.about-contact a:first-child');
      ig.textContent = data.instagram;
      ig.href = `https://instagram.com/${data.instagram.replace('@', '')}`;

      const mail = document.querySelector('.about-contact a:last-child');
      mail.textContent = data.email;
      mail.href = `mailto:${data.email}`;
    }

// ✅ GLB에 UV가 없을 때 자동으로 UV를 생성해주는 함수 (OBJ에서 하던 방식 대체)
function ensureUVsForModel(root) {
  root.traverse((child) => {
    if (!child.isMesh) return;

    const geo = child.geometry;
    if (!geo || geo.attributes.uv) return; // 이미 uv 있으면 패스

    geo.computeBoundingBox();
    const bb = geo.boundingBox;
    const size = new THREE.Vector3();
    bb.getSize(size);

    const pos = geo.attributes.position;
    const uv = new Float32Array(pos.count * 2);

    const denomX = size.x === 0 ? 1 : size.x;
    const denomY = size.y === 0 ? 1 : size.y;

    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i);
      const y = pos.getY(i);

      uv[i * 2 + 0] = (x - bb.min.x) / denomX;
      uv[i * 2 + 1] = (y - bb.min.y) / denomY;
    }

    geo.setAttribute('uv', new THREE.BufferAttribute(uv, 2));
    geo.attributes.uv.needsUpdate = true;
  });
}


    // Three.js Scene
    const scene = new THREE.Scene();
    scene.background = null;

    function getContainerHeight() {
      if (window.innerWidth <= 768) return window.innerHeight * 0.8;
      return window.innerHeight * 0.82;
    }

    const containerHeight = getContainerHeight();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / containerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, containerHeight);
    renderer.setClearColor(0x000000, 0);
    document.getElementById('container').appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
    directionalLight2.position.set(-5, -3, 3);
    scene.add(directionalLight2);

    let model = null;
    let autoRotationSpeed = 0.5;
    let modelScale = 1;
    let isDragging = false;
    let previousMouse = { x: 0, y: 0 };
    let isTransitioning = false;
    let currentPosterIndex = null;

    // 마우스 인터랙션
    const container = document.getElementById('container');

    container.addEventListener('mousedown', function(e) {
      isDragging = true;
      previousMouse = { x: e.clientX, y: e.clientY };
    });

    container.addEventListener('mousemove', function(e) {
      if (!isDragging || !model) return;

      const deltaX = e.clientX - previousMouse.x;
      const deltaY = e.clientY - previousMouse.y;

      model.rotation.y += deltaX * 0.01;
      model.rotation.x += deltaY * 0.01;

      previousMouse = { x: e.clientX, y: e.clientY };
    });

    container.addEventListener('mouseup', function() { isDragging = false; });
    container.addEventListener('mouseleave', function() { isDragging = false; });

    container.addEventListener('wheel', function(e) {
      e.preventDefault();
      camera.position.z += e.deltaY * 0.01;
      camera.position.z = Math.max(2, Math.min(20, camera.position.z));
    });

    // 터치 인터랙션 (모바일/태블릿)
    let touchStartDistance = 0;
    let initialZoom = 5;

    container.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        isDragging = true;
        previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      } else if (e.touches.length === 2) {
        isDragging = false;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchStartDistance = Math.sqrt(dx * dx + dy * dy);
        initialZoom = camera.position.z;
      }
    });

    container.addEventListener('touchmove', function(e) {
      e.preventDefault();

      if (e.touches.length === 1 && isDragging && model) {
        const deltaX = e.touches[0].clientX - previousMouse.x;
        const deltaY = e.touches[0].clientY - previousMouse.y;

        model.rotation.y += deltaX * 0.01;
        model.rotation.x += deltaY * 0.01;

        previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        const scale = touchStartDistance / distance;
        camera.position.z = initialZoom * scale;
        camera.position.z = Math.max(2, Math.min(20, camera.position.z));
      }
    }, { passive: false });

    container.addEventListener('touchend', function() { isDragging = false; });

    // 컨트롤
    document.getElementById('rotationSpeed').addEventListener('input', function(e) {
      autoRotationSpeed = parseFloat(e.target.value);
    });

    document.getElementById('scaleSlider').addEventListener('input', function(e) {
      const scale = parseFloat(e.target.value);
      if (model && !isTransitioning) {
        const finalScale = modelScale * scale;
        model.scale.set(finalScale, finalScale, finalScale);
      }
    });

    // 텍스처 전환 애니메이션
    function transitionTexture(posterIndex) {
      if (isTransitioning || !model) return;

      isTransitioning = true;
      currentPosterIndex = posterIndex;

      const targetScale = modelScale * parseFloat(document.getElementById('scaleSlider').value);
      const startRotation = model.rotation.y;
      const duration = 900;
      const startTime = Date.now();

      function animateOut() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / (duration / 2), 1);
        const eased = Math.sin(progress * Math.PI / 2);

        model.scale.setScalar(targetScale * (1 - eased * 0.95));
        model.rotation.y = startRotation + eased * Math.PI * 2;

        if (progress < 1) {
          requestAnimationFrame(animateOut);
        } else {
          loadTexture(posterIndex, targetScale);
        }
      }

      animateOut();
    }

    function loadTexture(posterIndex, targetScale) {
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(`poster${posterIndex}.jpg`, function(texture) {
        texture.flipY = false;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;

        // GLB는 보통 그룹(scene)이므로 traverse로 모두 적용
        model.traverse(function(child) {
          if (child.isMesh) {
            child.material = new THREE.MeshStandardMaterial({
              map: texture,
              metalness: 0.1,
              roughness: 0.8,
              side: THREE.DoubleSide
            });
            child.material.needsUpdate = true;
          }
        });

        const startRotation = model.rotation.y;
        const startTime = Date.now();
        const duration = 900;

        function animateIn() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / (duration / 2), 1);
          const eased = 1 - Math.cos(progress * Math.PI / 2);

          model.scale.setScalar(targetScale * (0.05 + eased * 0.95));
          model.rotation.y = startRotation + eased * Math.PI * 2;

          if (progress < 1) {
            requestAnimationFrame(animateIn);
          } else {
            model.scale.setScalar(targetScale);
            isTransitioning = false;
          }
        }

        animateIn();
      });
    }

    // ✅ pig.glb 로드 (OBJ 대신)
    const gltfLoader = new THREE.GLTFLoader();
    gltfLoader.load(
      'pig.glb',
      function(gltf) {
        model = gltf.scene;

        ensureUVsForModel(model); 

        // 안전하게 모든 메쉬 DoubleSide 처리(뒤집힘 방지)
        model.traverse((child) => {
          if (child.isMesh) {
            if (child.material) {
              child.material.side = THREE.DoubleSide;
              child.material.needsUpdate = true;
            }
          }
        });

        // 화면에 맞게 자동 스케일/센터링 (기존 OBJ 로직과 동일한 의도)
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 5 / maxDim;

        model.scale.setScalar(scale);
        modelScale = scale;

        model.position.set(-center.x * scale, -center.y * scale, -center.z * scale);

        scene.add(model);
        document.getElementById('loadingScreen').classList.add('hidden');
      },
      undefined,
      function(error) {
        console.error('GLB 로드 실패:', error);
        document.getElementById('loadingScreen').classList.add('hidden');
      }
    );

    // 포스터 갤러리 생성
    const gallery = document.getElementById('posterGallery');
    for (let i = 1; i <= 18; i++) {
      const posterItem = document.createElement('div');
      posterItem.className = 'poster-item';
      posterItem.dataset.poster = i;

      const img = document.createElement('img');
      img.src = `poster${i}.jpg`;
      img.onerror = function() {
        posterItem.innerHTML = '<div class="poster-placeholder">Poster ' + i + '</div>';
      };
      posterItem.appendChild(img);

      posterItem.addEventListener('click', function() {
        document.querySelectorAll('.poster-item').forEach(item => item.classList.remove('active'));
        posterItem.classList.add('active');

        currentPosterSelection = i;
        transitionTexture(i);

        // About 이미지 및 텍스트 업데이트
        document.querySelector('#aboutImage img').src = `poster${i}.jpg`;
        updateAboutText(i);
      });

      gallery.appendChild(posterItem);
    }

    // 버튼 기능
    document.getElementById('button1').addEventListener('click', function() {
      location.reload();
    });

    document.getElementById('button2').addEventListener('click', function() {
      document.getElementById('infoBox').classList.toggle('show');
    });

    // About 토글
    document.getElementById('toggleButton').addEventListener('click', function() {
      const overlay = document.getElementById('aboutOverlay');
      const button = document.getElementById('toggleButton');

      if (overlay.classList.contains('show')) {
        overlay.classList.remove('show');
        button.classList.remove('back');
        button.textContent = 'ABOUT';
      } else {
        overlay.classList.add('show');
        button.classList.add('back');
        button.textContent = 'BACK';
      }
    });

    // 방향키로 포스터 선택 (데스크탑)
    let currentPosterSelection = 1;

    window.addEventListener('keydown', function(e) {
      if (window.innerWidth <= 768) return;

      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        currentPosterSelection--;
        if (currentPosterSelection < 1) currentPosterSelection = 18;
        selectPoster(currentPosterSelection);
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        currentPosterSelection++;
        if (currentPosterSelection > 18) currentPosterSelection = 1;
        selectPoster(currentPosterSelection);
      }
    });

    function selectPoster(index) {
      const posterItem = document.querySelector(`.poster-item[data-poster="${index}"]`);
      if (posterItem) {
        posterItem.click();
        posterItem.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
      }
    }

    // 애니메이션 (최적화)
    let lastTime = Date.now();
    const targetFPS = 60;
    const frameInterval = 1000 / targetFPS;

    function animate() {
      requestAnimationFrame(animate);

      const now = Date.now();
      const delta = now - lastTime;

      if (delta > frameInterval) {
        lastTime = now - (delta % frameInterval);

        if (model && autoRotationSpeed > 0 && !isDragging && !isTransitioning) {
          model.rotation.y += autoRotationSpeed * 0.01;
        }

        renderer.render(scene, camera);
      }
    }
    animate();

    // 창 크기 조절
    window.addEventListener('resize', function() {
      const containerHeight = getContainerHeight();
      camera.aspect = window.innerWidth / containerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, containerHeight);
    });
  </script>
</body>
</html>
